from typing import Sequence, Union, Tuple, List
from copy import copy
from math import *
import numpy as np

from fuselage import *
from isolated_plane import *
from libs.Atmosphere import atmo
from libs.handler import *
import libs.AeroBDSM as AeroBDSM


_IsolatedPlane = Union[IsolatedPlane, IsolatedPlane_RotatingConsoles, IsolatedPlane_RotatingBack]

class ConsoleOnFuselage:
    '''
    Класс расчёта АДХ консоли, установленной на фюзеляже
    '''
    def __init__(self, IsP: _IsolatedPlane, psi: float, x_b: float, isReflected: bool = None) -> None:
       
        self.IsP = IsP            # объект изолированной несущей поверхности (монопланного крыла, составленного из двух консолей)
        self.psi = psi            # угол расположения консоли в поперечной плоскости ZY (отсчитывается от оси Z против часовой стрелки)
        self.x_b = x_b            # расстояние от носа фюзеляжа до начала бортовой хорды консоли

        # isReflected свойство, отвечающее за отражение консоли (и её АДХ по углу alpha) относительно её базовой плоскости
        # по умолчанию, если не задано, то консоли устанавливаемые на левом борту ЛА нужно отразить
        # это не имеет значения для несущих поверхностей с симметричным профилем, у которых при alpha=0 c_y=0 и зависимость c_y(alpha) симметричная
        if isReflected is None:
            if pi/2 < self.psi < 3*pi/2:     #здесь стоит ещё подумать, может быть в одном поставить <= ?
                self.isReflected = True
            else:
                self.isReflected = False
        else:
            self.isReflected = isReflected

        # пояснение: установка консоли на фюзеляж на угле psi предполагает простое вращение её от 0 до psi вокруг фюзеляжа,
        # таким образом, если консоль имеет выпуклый (дозвуковой) профиль и при psi=0 выпуклая сторона находится сверху,
        # то при довороте этой консоли на psi=180 выпуклая сторона окажется снизу, поэтому обычно в этом случае нужно отразить консоль
                  
        self.S_1c = self.IsP.S / 2  # площадь одной консоли, м^2
        self.l_1c = self.IsP.l / 2  # размах (длина) одной консоли (полуразмах изолированного крыла), м

    def InterferenceCoefs(self, fuselage: Fuselage, M, H):
        '''
        Расчёт коэффициентов интерференции консоли и фюзеляжа
        '''
        
        # Относительный диаметр фюзеляжа (отношение диаметра к полному размаху крыла из двух консолей, установленного на фюзеляж)
        DD = fuselage.D / (self.IsP.l + fuselage.D)

        # Коэффициент интерференции по теории тонкого тела, характеризующий изменение нормальной силы собственно консолей
        # вследствие влияния на них фюзеляжа, для случая alpha_alpha (геометрические углы атаки консоли и фюзеляжа совпадают)
        k_alpha_alpha_theor = (1 + 0.41 * DD)**2 # ?ЛИЧ пишет, что это приближённая аппроксимация громоздкого выражения, может это то самое которое у Краснова и NACA?

        # Коэффициент интерференции по теории тонкого тела, характеризующий изменение общей нормальной силы консолей и фюзеляжа
        # вследствие их взаимного влияния, для случая alpha_alpha (геометрические углы атаки консоли и фюзеляжа совпадают)
        K_alpha_alpha_theor = (1 + DD)**2 

        
        # Поправочный множитель, учитывающий влияние сужения несущей поверхности
        kappa_eta = (1 + 3 * DD - self.IsP.zeta * DD * (1 - DD)) / (1 + DD)**2
        
        # Учёт влияния пограничного слоя фюзеляжа
        # Число Рейнольдса в сечении, проходящем через середину бортовой хорды консоли
        Re_ps = Mach_to_v(M, H) * (self.x_b + 0.5 * self.IsP.b_b) / atmo.nu(H)
        # Относительная толщина вытеснения (в сечении, проходящем через середину бортовой хорды консоли)
        deltadelta_ps = (self.x_b + 0.5 * self.IsP.b_b) / (fuselage.D * Re_ps**0.2) * 0.093 * (1 + 0.4 * M + 0.147 * M**2 - 0.006 * M**3)        
        # Поправочный множитель, учитывающий влияние пограничного слоя фюзеляжа для случая alpha_alpha
        kappa_ps_alpha_alpha = (1 - 2 * DD**2  / (1 - DD**2) * deltadelta_ps) * (1 -  DD / (1 - DD)  *  (1 - self.IsP.zeta) / (1 + self.IsP.zeta)  *  deltadelta_ps)

        # Вызываем библиотечную функцию, для определения поправочного множителя, учитывающего влияние числа Маха
        kappa_M = AeroBDSM.get_kappa_M(M).Value
        
        # Поправочный множитель, учитывающий влияние длины предшествующей части фюзеляжа (расположенной впереди от консоли)
        kappa_pre = 0.6 + 0.4 * (1 - exp( -0.5 * (self.x_b + 0.5 * self.IsP.b_b) / fuselage.D) )


        # Коэффициент интерференции с учётом поправок
        k_alpha_alpha = k_alpha_alpha_theor * kappa_eta * kappa_ps_alpha_alpha * kappa_M * kappa_pre

        # Учёт влияния длины последующей части фюзеляжа, расположенной позади от консоли
        # При дозвуковых скоростях индуцированная на фюзеляже сила полностью реализуется, независимо от длины фюзеляжа позади консолей
        if M <= 1.0:
            kappa_pos = 1.0
        else:
            # Коэффициент, характеризующий форму эпюры погонной нагрузки
            c_q = (4 + self.IsP.zeta) * (1 + 8 * DD**2)
            # Длина полувитка (половина шага) винтовой линии Маха
            L_Ml = 0.5 * pi * fuselage.D * sqrt(M**2 - 1)
            # Длина бортовой хорды консоли в долях длины полувитка винтовой линии Маха
            bb_b = self.IsP.b_b / L_Ml
            # Длина части фюзеляжа, расположенной позади консоли (от конца бортовой хорды до донного среза) в долях длины полувитка винтовой линии Маха ?а если она сужается
            LL_pos = (fuselage.L - self.x_b - self.IsP.b_b) / L_Ml

            # Поправочный множитель, учитывающий неполноту реализации индуцированной на фюзеляже силы (K_alpha_alpha - k_alpha_alpha)
            kappa_pos =  1 - sqrt(pi) / (2 * bb_b * sqrt(c_q)) * ( Phi( (bb_b + LL_pos) * sqrt(2 * c_q) ) - Phi( LL_pos * sqrt(2 * c_q) ) )
     
        K_alpha_alpha = (k_alpha_alpha_theor + (K_alpha_alpha_theor - k_alpha_alpha_theor) * kappa_pos) * kappa_eta * kappa_ps_alpha_alpha * kappa_M * kappa_pre



        # Коэффициент интерференции по теории тонкого тела, характеризующий изменение нормальной силы собственно консолей
        # вследствие влияния на них фюзеляжа, для случая delta0 (консоль установлена под углом атаки delta, угол атаки фюзеляжа нулевой)
        k_delta0_theor = k_alpha_alpha_theor**2 / K_alpha_alpha_theor
        
        # Поправочный множитель, учитывающий влияние пограничного слоя фюзеляжа для случая delta0
        kappa_ps_delta0 = (1 - DD * (1 + deltadelta_ps)) * (1 - (1 - self.IsP.zeta) / (1 + self.IsP.zeta - 2 * self.IsP.zeta * DD) * DD * (1 + deltadelta_ps)) / ((1 - DD) * (1 - (1 - self.IsP.zeta) / (1 + self.IsP.zeta - 2 * self.IsP.zeta * DD) * DD))
        
        # Коэффициент интерференции с учётом поправок
        k_delta0 = k_delta0_theor * kappa_eta * kappa_ps_delta0 * kappa_M  #почему здесь не учитывается kappa_pre ?

        
        # Коэффициент интерференции по теории тонкого тела, характеризующий изменение общей нормальной силы консолей и фюзеляжа
        # вследствие их взаимного влияния, для случая delta0 (консоль установлена под углом атаки delta, угол атаки фюзеляжа нулевой)
        K_delta0_theor = k_alpha_alpha_theor

        # Коэффициент интерференции с учётом поправок
        K_delta0 = (k_delta0_theor + (K_delta0_theor - k_delta0_theor) * kappa_pos) * kappa_eta * kappa_ps_delta0 * kappa_M #почему здесь не учитывается kappa_pre ?
        
        return k_alpha_alpha, K_alpha_alpha, k_delta0, K_delta0
    
           
    def c_y(self, fuselage: Fuselage, M: float, alpha: float, delta: float = 0, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчёт коэффициента нормальной силы
        (сила направленная по нормали к статичной части консоли, установленной на фюзеляж
        с учётом нормальной силы изолированной консоли и индуцированных нормальных сил на консоли и на фюзеляже)
        (консоль может иметь поворотную часть)

        Ввод:   M: float - число Маха
                alpha: float - угол атаки статичной части консоли, рад
                delta: float - угол отклонения рулей, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности консоли, К
        Вывод:  c_y: float - коэффициент нормальной силы (нормальной к статичной части консоли)
        '''

        # Если консоль отражённая, то знак углов alpha и delta нужно поменять, а затем снова поменять знак полученного c_y
        if self.isReflected == True:
            alpha = -alpha
            delta = -delta

        # Вычисляем коэффициенты интерференции консоли с фюзеляжем
        k_alpha_alpha, K_alpha_alpha, k_delta0, K_delta0 = self.InterferenceCoefs(fuselage, M, H)     

        # Если консоль неповоротная
        if type(self.IsP) is IsolatedPlane:
            # коэффициент нормальной силы изолированной консоли
            c_y_IsP = self.IsP.c_y(M, alpha)

            # коэффициент нормальной силы консоли с учётом дополнительной индуцированной на консоли силы определяется по эффективному углу атаки
            alpha_eff = k_alpha_alpha * alpha
            c_y_P = self.IsP.c_y(M, alpha_eff)
            # тогда коэффициент дополнительной нормальной силы индуцированной на консоли от присутствия фюзеляжа определяется как
            c_y_iP = c_y_P - c_y_IsP           

        # Если консоль поворотная
        elif type(self.IsP) is IsolatedPlane_RotatingConsoles:
            # коэффициент нормальной силы изолированной консоли (по нормали к статичной части консоли)
            c_y_IsP = self.IsP.c_y(M, alpha, delta, H, xx_t, T_s)

            # коэффициент нормальной силы консоли с учётом дополнительной индуцированной на консоли силы определяется по эффективному углу атаки и отклонения руля
            alpha_eff = k_alpha_alpha * alpha
            delta_eff = k_delta0 * delta
            c_y_P = self.IsP.c_y(M, alpha_eff, delta_eff, H, xx_t, T_s)
            # тогда коэффициент дополнительной нормальной силы индуцированной на консоли от присутствия фюзеляжа определяется как
            c_y_iP = c_y_P - c_y_IsP

        # коэффициент дополнительной нормальной силы индуцированной на фюзеляже от присутствия консоли
        c_y_iF = (K_alpha_alpha / k_alpha_alpha - 1) * c_y_P

        # Суммарный коэффициент нормальной силы с учётом нормальной силы изолированной консоли и индуцированных нормальных сил на консоли и на фюзеляже
        c_y = c_y_IsP + c_y_iP + c_y_iF

        # Если консоль отражённая, то знак c_y нужно поменять, поскольку ранее был поменян знак угла атаки
        if self.isReflected == True:
            c_y = -c_y

        return c_y

    def c_x(self, fuselage: Fuselage, M: float, alpha: float, delta: float = 0, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчёт коэффициента продольной силы
        (сила направленная вдоль статичной части консоли, установленной на фюзеляж, и вдоль оси фюзеляжа)        
        (консоль может иметь поворотную часть)

        Ввод:   M: float - число Маха
                alpha: float - угол атаки статичной части консоли, рад
                delta: float - угол отклонения рулей, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности консоли, К
        Вывод:  c_x: float - коэффициент продольной силы (направленной вдоль статичной части консоли, установленной на фюзеляж, и вдоль оси фюзеляжа)
        '''

        # Если консоль отражённая, то знак углов alpha и delta нужно поменять
        if self.isReflected == True:
            alpha = -alpha
            delta = -delta

        # Если консоль неповоротная
        if type(self.IsP) is IsolatedPlane:
            # коэффициент продольной силы изолированной консоли
            c_x_IsP = self.IsP.c_x(M, alpha, H, xx_t, T_s)          

        # Если консоль поворотная
        elif type(self.IsP) is IsolatedPlane_RotatingConsoles:
            # коэффициент продольной силы изолированной консоли (вдоль статичной части)
            c_x_IsP = self.IsP.c_x(M, alpha, delta, H, xx_t, T_s)            

        return c_x_IsP

    def x_d(self, fuselage: Fuselage, M: float, alpha: float, delta: float = 0, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчёт продольной координаты центра давления
        (с учётом нормальной силы изолированной консоли и индуцированных нормальных сил на консоли и на фюзеляже)

        Ввод:   M: float - число Маха
                alpha: float - угол атаки статичной части консоли, рад
                delta: float - угол отклонения рулей, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности консоли, К
        Вывод:  x_d: float - продольная координата центра давления, отсчитываемая от носа фюзеляжа, м
        '''

        # Если консоль отражённая, то знак углов alpha и delta нужно поменять
        if self.isReflected == True:
            alpha = -alpha
            delta = -delta   

        # Вычисляем коэффициенты интерференции консоли с фюзеляжем
        k_alpha_alpha, K_alpha_alpha, k_delta0, K_delta0 = self.InterferenceCoefs(fuselage, M, H)     

        # Если консоль неповоротная
        if type(self.IsP) is IsolatedPlane:
            # коэффициент нормальной силы изолированной консоли
            c_y_IsP = self.IsP.c_y(M, alpha)
            # эта сила приложена в центре давления изолированной консоли
            x_d_IsP = self.x_b + self.IsP.x_d(M, alpha)

            # коэффициент нормальной силы консоли с учётом дополнительной индуцированной на консоли силы определяется по эффективному углу атаки
            alpha_eff = k_alpha_alpha * alpha
            c_y_P = self.IsP.c_y(M, alpha_eff)
            # тогда коэффициент дополнительной нормальной силы индуцированной на консоли от присутствия фюзеляжа определяется как
            c_y_iP = c_y_P - c_y_IsP           

        # Если консоль поворотная
        elif type(self.IsP) is IsolatedPlane_RotatingConsoles:
            # коэффициент нормальной силы изолированной консоли (по нормали к статичной части консоли)
            c_y_IsP = self.IsP.c_y(M, alpha, delta, H, xx_t, T_s)
            # эта сила приложена в центре давления изолированной консоли
            x_d_IsP = self.x_b + self.IsP.x_d(M, alpha, delta, H, xx_t, T_s)

            # коэффициент нормальной силы консоли с учётом дополнительной индуцированной на консоли силы определяется по эффективному углу атаки и отклонения руля
            alpha_eff = k_alpha_alpha * alpha
            delta_eff = k_delta0 * delta
            c_y_P = self.IsP.c_y(M, alpha_eff, delta_eff, H, xx_t, T_s)
            # тогда коэффициент дополнительной нормальной силы индуцированной на консоли от присутствия фюзеляжа определяется как
            c_y_iP = c_y_P - c_y_IsP

        #Рассчитываем координату точки приложения дополнительной нормальной силы, индуцированная на консоли от присутствия фюзеляжа 
        # Относительный диаметр фюзеляжа (отношение диаметра к полному размаху крыла из двух консолей, установленного на фюзеляж)
        DD = fuselage.D / (self.IsP.l + fuselage.D)
        # Вызываем библиотечную функцию для определения множителя, учитывающего влияние относительного диаметра фюзеляжа на координату приложения дополнительной нормальной силы консолей
        xi_D = AeroBDSM.get_xi_D(DD).Value        
        # Дополнительная нормальная сила, индуцированная на консоли от присутствия фюзеляжа приложена в координате
        x_d_iP = self.x_b + self.IsP.x_F_alpha(M) - xi_D * 0.5 * self.IsP.l * tan(self.IsP.chi_05) #здесь фокус, а может центр давления поставить?

        
        # коэффициент дополнительной нормальной силы индуцированной на фюзеляже от присутствия консоли (а если сила создаётся при нулевом альфа за счёт дельта, то должно быть K_delta0 и k_delta0 как в (5.58)? но из с.190 следует что надо делать так как есть)
        c_y_iF = (K_alpha_alpha / k_alpha_alpha - 1) * c_y_P

        #Рассчитываем координату точки приложения дополнительной нормальной силы индуцированной на фюзеляже от присутствия консоли        
        # Относительная координата фокуса бортового сечения консоли
        xx_Fb = self.IsP.x_F_alpha(M) / self.IsP.b_A + 0.02 * self.IsP.lambd * tan(self.IsP.chi_05) #здесь фокус, а может центр давления поставить?
        # Учёт влияния длины последующей части фюзеляжа, расположенной позади от консоли
        # При дозвуковых скоростях индуцированная на фюзеляже сила полностью реализуется, независимо от длины фюзеляжа позади консолей
        if M <= 1.0:
            kappa_pos = 1.0
            kappa_pos1 = 1.0
        else:
            # Коэффициент, характеризующий форму эпюры погонной нагрузки
            c_q = (4 + self.IsP.zeta) * (1 + 8 * DD**2)
            # Длина полувитка (половина шага) винтовой линии Маха
            L_Ml = 0.5 * pi * fuselage.D * sqrt(M**2 - 1)
            # Длина бортовой хорды консоли в долях длины полувитка винтовой линии Маха
            bb_b = self.IsP.b_b / L_Ml
            # Длина части фюзеляжа, расположенной позади консоли (от конца бортовой хорды до донного среза) в долях длины полувитка винтовой линии Маха ?а если она сужается
            LL_pos = (fuselage.L - self.x_b - self.IsP.b_b) / L_Ml

            # Поправочный множитель, учитывающий неполноту реализации индуцированной на фюзеляже силы (K_alpha_alpha - k_alpha_alpha)
            kappa_pos =  1 - sqrt(pi) / (2 * bb_b * sqrt(c_q)) * ( Phi( (bb_b + LL_pos) * sqrt(2 * c_q) ) - Phi( LL_pos * sqrt(2 * c_q) ) )
            kappa_pos1 = 1 - ( exp(-c_q * LL_pos**2) - exp(-c_q * (bb_b + LL_pos)**2) ) / (c_q * bb_b**2) + sqrt(pi) / ( bb_b * sqrt(c_q) ) * Phi( LL_pos * sqrt(2 * c_q) )
        # Координата точки приложения дополнительной нормальной силы индуцированной на фюзеляже от присутствия консоли
        x_d_iF = self.x_b + self.IsP.b_b * xx_Fb * kappa_pos * kappa_pos1

        # Суммарный коэффициент нормальной силы с учётом нормальной силы изолированной консоли и индуцированных нормальных сил на консоли и на фюзеляже
        c_y = self.c_y(fuselage, M, alpha, delta, H, xx_t, T_s)

        # При нулевой нормальной силе центр давления отсутствует, условно принимаем что центр давления совпадает с фокусом
        if c_y == 0:
            x_F = (x_d_IsP + (k_alpha_alpha - 1) * x_d_iP + (K_alpha_alpha - k_alpha_alpha) * x_d_iF) / K_alpha_alpha
            x_d = x_F
        else:
            # Центр давления определяем таким образом, чтобы момент, создаваемый суммарной нормальной силой, был равен сумме моментов от трёх её составляющих сил
            x_d = (c_y_IsP * x_d_IsP + c_y_iP * x_d_iP + c_y_iF * x_d_iF) / c_y

        #print(alpha)
        #print(c_y_IsP, c_y_iP, c_y_iF, c_y)
        #print(x_d_IsP, x_d_iP, x_d_iF, x_d)

        return x_d
    
    def z_d(self, fuselage: Fuselage, M: float, alpha: float, delta: float = 0, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчёт поперечной координаты центра давления
        (с учётом нормальной силы изолированной консоли и индуцированных нормальных сил на консоли и на фюзеляже)

        Ввод:   M: float - число Маха
                alpha: float - угол атаки статичной части консоли, рад
                delta: float - угол отклонения рулей, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности консоли, К
        Вывод:  z_d: float - поперечная координата центра давления, отсчитываемая от оси фюзеляжа, м
        '''   

        # Вычисляем коэффициенты интерференции консоли с фюзеляжем
        k_alpha_alpha, K_alpha_alpha, k_delta0, K_delta0 = self.InterferenceCoefs(fuselage, M, H)     

        # Если консоль неповоротная
        if type(self.IsP) is IsolatedPlane:
            # коэффициент нормальной силы изолированной консоли
            c_y_IsP = self.IsP.c_y(M, alpha)
            # эта сила приложена в центре давления изолированной консоли
            z_d_IsP = fuselage.D / 2 + self.IsP.z_dc(M, alpha)

            # коэффициент нормальной силы консоли с учётом дополнительной индуцированной на консоли силы определяется по эффективному углу атаки
            alpha_eff = k_alpha_alpha * alpha
            c_y_P = self.IsP.c_y(M, alpha_eff)
            # тогда коэффициент дополнительной нормальной силы индуцированной на консоли от присутствия фюзеляжа определяется как
            c_y_iP = c_y_P - c_y_IsP           

        # Если консоль поворотная
        elif type(self.IsP) is IsolatedPlane_RotatingConsoles:
            # коэффициент нормальной силы изолированной консоли (по нормали к статичной части консоли)
            c_y_IsP = self.IsP.c_y(M, alpha, delta, H, xx_t, T_s)
            # эта сила приложена в центре давления изолированной консоли
            z_d_IsP = fuselage.D / 2  + self.IsP.z_dc(M, alpha, delta)

            # коэффициент нормальной силы консоли с учётом дополнительной индуцированной на консоли силы определяется по эффективному углу атаки и отклонения руля
            alpha_eff = k_alpha_alpha * alpha
            delta_eff = k_delta0 * delta
            c_y_P = self.IsP.c_y(M, alpha_eff, delta_eff, H, xx_t, T_s)
            # тогда коэффициент дополнительной нормальной силы индуцированной на консоли от присутствия фюзеляжа определяется как
            c_y_iP = c_y_P - c_y_IsP

        #Рассчитываем координату точки приложения дополнительной нормальной силы, индуцированная на консоли от присутствия фюзеляжа 
        # Относительный диаметр фюзеляжа (отношение диаметра к полному размаху крыла из двух консолей, установленного на фюзеляж)
        DD = fuselage.D / (self.IsP.l + fuselage.D)
        # Вызываем библиотечную функцию для определения множителя, учитывающего влияние относительного диаметра фюзеляжа на координату приложения дополнительной нормальной силы консолей
        xi_D = AeroBDSM.get_xi_D(DD).Value        
        # Дополнительная нормальная сила, индуцированная на консоли от присутствия фюзеляжа приложена в координате
        z_d_iP = z_d_IsP - xi_D * 0.5 * self.IsP.l #здесь ЦД, а может надо координату САХ поставить?

        
        # коэффициент дополнительной нормальной силы индуцированной на фюзеляже от присутствия консоли
        c_y_iF = (K_alpha_alpha / k_alpha_alpha - 1) * c_y_P
       
        # Координата точки приложения дополнительной нормальной силы индуцированной на фюзеляже от присутствия консоли
        z_d_iF = fuselage.D / 4     #условно принимаем, что она приложена на половине радиуса фюзеляжа, более хороших идей нет?

        # Суммарный коэффициент нормальной силы с учётом нормальной силы изолированной консоли и индуцированных нормальных сил на консоли и на фюзеляже
        c_y = self.c_y(fuselage, M, alpha, delta, H, xx_t, T_s)

        # При нулевой нормальной силе центр давления отсутствует, условно принимаем что центр давления совпадает с фокусом
        if c_y == 0:
            z_F = (z_d_IsP + (k_alpha_alpha - 1) * z_d_iP + (K_alpha_alpha - k_alpha_alpha) * z_d_iF) / K_alpha_alpha
            z_d = z_F
        else:
            # Центр давления определяем таким образом, чтобы момент, создаваемый суммарной нормальной силой, был равен сумме моментов от трёх её составляющих сил
            z_d = (c_y_IsP * z_d_IsP + c_y_iP * z_d_iP + c_y_iF * z_d_iF) / c_y        

        #print(alpha)
        #print(c_y_IsP, c_y_iP, c_y_iF, c_y)
        #print(z_d_IsP, z_d_iP, z_d_iF, z_d)

        return z_d
    
    def c_n_P (self, fuselage: Fuselage, M: float, alpha: float, delta: float = 0, H: float = 0) -> float:
        '''
        Расчёт коэффициента нормальной силы несущей поверхности
        (сила направленная по нормали к консоли, если консоль статичная или полностью поворотная,
        если консоль имеет статичную и поворотную часть, то - по нормали к консоли установленной под эффективным углом.
        С учётом нормальной силы изолированной консоли и индуцированной силы на консоли, но без учёта индуцированной силы на фюзеляже)
        (консоль может иметь поворотную часть)

        Ввод:   M: float - число Маха
                alpha: float - угол атаки статичной части консоли, рад
                delta: float - угол отклонения рулей, рад
                H: float - высота полета, м                
        Вывод:  c_n_P: float - коэффициент нормальной силы (нормали к консоли, если консоль статичная или полностью поворотная)
        '''

        # Если консоль отражённая, то знак углов alpha и delta нужно поменять, а затем снова поменять знак полученного c_n
        if self.isReflected == True:
            alpha = -alpha
            delta = -delta

        # Вычисляем коэффициенты интерференции консоли с фюзеляжем
        k_alpha_alpha, K_alpha_alpha, k_delta0, K_delta0 = self.InterferenceCoefs(fuselage, M, H)     

        # Если консоль неповоротная
        if type(self.IsP) is IsolatedPlane:
            # коэффициент нормальной силы консоли с учётом дополнительной индуцированной на консоли силы определяется по эффективному углу атаки
            alpha_eff = k_alpha_alpha * alpha
            c_y_P = self.IsP.c_y(M, alpha_eff)
            c_n_P = c_y_P  # Поскольку консоль неповоротная        

        # Если консоль поворотная
        elif type(self.IsP) is IsolatedPlane_RotatingConsoles:
            # коэффициент нормальной силы консоли с учётом дополнительной индуцированной на консоли силы определяется по эффективному углу атаки и отклонения руля
            alpha_eff = k_alpha_alpha * alpha
            delta_eff = k_delta0 * delta
            c_n_P = self.IsP.IsP.c_y(M, self.IsP.alpha_eff(M, alpha_eff, delta_eff))
        

        # Если консоль отражённая, то знак c_y нужно поменять, поскольку ранее был поменян знак угла атаки
        if self.isReflected == True:
            c_n_P = -c_n_P

        return c_n_P