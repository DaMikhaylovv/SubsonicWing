from typing import Sequence, Union, Tuple, List
from copy import copy
from math import *
import numpy as np

from fuselage import *
from isolated_plane import *
from __ConsoleOnFuselage import *
from libs.Atmosphere import atmo
from libs.handler import *
import libs.AeroBDSM as AeroBDSM

class LA:
    '''
    Класс расчёта АДХ летательного аппарата, состоящего из фюзеляжа и консолей несущих поверхностей, установленных на фюзеляже
    '''
    def __init__(self, fuselage: Fuselage, consolesI: list[ConsoleOnFuselage], consolesII: list[ConsoleOnFuselage] = None, S: float = None, L: float = None) -> None:
        '''
        fuselage    -   объект фюзеляжа
        consolesI   -   список передних консолей (I пояс консолей)
        consolesII  -   список задних консолей (II пояс консолей)
        S           -   характерная площадь ЛА, м^2
        L           -   характерная длина ЛА, м
        '''
        self.fuselage = fuselage
        self.consolesI = consolesI
        self.consolesII = consolesII

        if S is None:
            self.S = self.fuselage.S_m
        else:
            self.S = S
        
        if L is None:
            self.L = self.fuselage.L
        else:
            self.L = L

    def get_ADCH(self, M: float, alpha: float, phi_alpha: float, delta_I: list[float] = None, delta_II: list[float] = None, H: float = 0, isActive: bool = False, xx_0: float = 0, x_t: float = None, T_s: float = None) -> float:
        '''
        Расчет коэффициентов аэродинамических сил и моментов

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
                phi_alpha: float - аэродинамический угол крена, рад
                delta_I: float - углы отклонения рулей передних консолей (при наличи), рад
                delta_II: float - углы отклонения рулей задних консолей (при наличи), рад
                H: float - высота полета, м
                isActive: float - режим работы двигателя: активный (True), пассивный (False)
                xx_0: float - относительная координата центра вращения в долях длины фюзеляжа (от носа) 
                x_t: float - координата точки перехода ламинарного пограничного слоя в турбулентный (от носа), м
                T_s: float - средняя температура поверхности носовой части летательного аппарата, К
                
        Вывод:  c_x: float - коэффициент продольной силы
                c_y: float - коэффициент нормальной силы
                c_z: float - коэффициент поперечной силы
        '''
        
        # Координата, относительно которой определяются моменты
        x_0 = xx_0 * self.fuselage.L # А если характерный размер ЛА выбран как хорда крыла, может надо относительно неё это делать? Самолётчики это любят наверное
               
        # Коэффициент продольной силы фюзеляжа (для осуществления дальнейшего суммирования с c_x несущих поверхностей переприводим коэффициенты к единой характерной площади S летательного аппарата)
        c_x_F = self.fuselage.c_x(M, alpha, H, isActive, x_t, T_s) * self.fuselage.S_m / self.S
        # Коэффициент нормальной силы фюзеляжа, создаваемой в плоскости пространственного угла атаки    
        c_n_F = self.fuselage.c_y(M, alpha) * self.fuselage.S_m / self.S
        # Коэффициенты нормальной и поперечной силы фюзеляжа, определяются путём проецирования нормальной силы фюзеляжа,
        # создаваемой в плоскости пространственного угла атаки на оси Oy и Oz связанной СК ЛА. ?Здесь не учтены области затенения консолями уменьшающие Sbok
        c_y_F = c_n_F * cos(phi_alpha)        
        c_z_F = -c_n_F * sin(phi_alpha) # поскольку при повороте на угол phi_alpha против часовой стрелки нормальная ось получается направлена противоположно от Oz ЛА, нужно поставить знак минус
        # Координата x центра давления фюзеляжа
        x_d_F = self.fuselage.x_d(M, alpha)
        # Координата у центра давления фюзеляжа
        у_d_F = 0       # (предполагаем, что центр давления фюзеляжа лежит на его оси)
        # Координата z центра давления фюзеляжа
        z_d_F = 0       # (предполагаем, что центр давления фюзеляжа лежит на его оси)

        # Коэффициенты моментов, создаваемые фюзеляжем (с учётом приведения коэффициента момента к характерной длине ЛА L)
        m_x_F = (c_y_F * z_d_F  +  c_z_F * у_d_F) / self.L
        m_y_F = - c_z_F * (x_0 - x_d_F) / self.L
        m_z_F = c_y_F * (x_0 - x_d_F) / self.L

        
        
        # Коэффициент торможения потока при переходе через скачок уплотнения, создаваемый носовой частью
        kM_I = self.fuselage.nosCil.kM(M)
        # Число Маха потока набегающего на I консоли, с учётом торможения в скачке уплотнения, создаваемым носовой частью
        M_I = M * sqrt(kM_I) # а что если какие-то консоли выходят за пределы носового конуса Маха?

        # Коэффициенты продольных сил консолей, установленных на фюзеляж, следует просуммировать
        # Коэффициенты нормальной силы консолей, установленных на фюзеляж, определяются в плоскости нормальной к статичной части консоли,
        # поэтому угол атаки и нормальную силу нужно спроецировать в зависимости от поперечного угла установки каждой консоли        
        c_x_I = 0
        c_y_I = 0
        c_z_I = 0
        # Коэффициенты моментов получаются как сумма моментов от проекций силы каждой консоли
        m_x_I = 0
        m_y_I = 0
        m_z_I = 0

        c_nc_I = [None] * len(self.consolesI) # Массив для сохранения коэффициентов нормальной силы (нормали к консоли, если консоль статичная или полностью поворотная), понадобятся позже для расчёта скоса потока

        # Для расчёта АДХ I несущих поверхностей необходимо определить относительное положение точки перехода ламинарного пограничного слоя в турбулентный        
        if x_t is None:
            # если x_t не задано, то вызываем функцию для расчёта этой координаты на фюзеляже
            x_t_F = self.fuselage.x_t(M, H, T_s)
            if x_t_F < self.consolesI[0].x_b: #здесь для расчёта берётся только 0 консоль, а что если они разные, осреднять?
                # если переход на фюзеляже наступает впереди несущих поверхностей, то они находятся в полностью турбулентном пограничном слое, поэтому
                xx_t_I = 0
            else:
                # вызываем функцию для расчёта этой координаты на изолированной несущей поверхности
                x_t_IsP_I = self.consolesI[0].IsP.xx_t(M, H, T_s) * self.consolesI[0].IsP.b_b + self.consolesI[0].x_b
                if x_t_F < x_t_IsP_I:
                    # переход на фюзеляже находится в пределах консоли, но впереди x_t изолированной консоли, поэтому принимаем координату от фюзеляжа, переходя к относительной координате
                    xx_t_I = (x_t_F - self.consolesI[0].x_b) /  self.consolesI[0].IsP.b_b
                else:
                    # x_t изолированной консоли находится впереди x_t фюзеляжа, поэтому принимаем её
                    xx_t_I = (x_t_IsP_I - self.consolesI[0].x_b) /   self.consolesI[0].IsP.b_b
            

        for i in range(len(self.consolesI)):
            # Поперечный угол установки консоли по отношению к плоскости пространственного угла атаки
            psi_alpha_i = self.consolesI[i].psi - phi_alpha
            # Угол атаки, под которым получается установлена статичная часть i-ой консоли по отношению к набегающему потоку
            alpha_c_i = alpha * cos(psi_alpha_i)
            
            if delta_I is None:
                # Коэффициент продольной силы i-ой консоли в системе координат, связанной с консолью с учётом коэфф. торможения и приведения к единой характерной площади S летательного аппарата
                c_xс_I_i = self.consolesI[i].c_x(self.fuselage, M_I, alpha_c_i, H = H, xx_t = xx_t_I, T_s = T_s) * kM_I * self.consolesI[i].S_1c /  self.S
                # Коэффициент нормальной силы i-ой консоли в системе координат, связанной с консолью с учётом коэфф. торможения и приведения к единой характерной площади S летательного аппарата
                c_yc_I_i = self.consolesI[i].c_y(self.fuselage, M_I, alpha_c_i, H = H, xx_t = xx_t_I, T_s = T_s) * kM_I * self.consolesI[i].S_1c /  self.S
                # Координата x центра давления i-ой консоли в системе координат, связанной с консолью (отсчитываемая от носа фюзеляжа)
                x_dc_I_i = self.consolesI[i].x_d(self.fuselage, M_I, alpha_c_i, H = H, xx_t = xx_t_I, T_s = T_s)
                # Координата z центра давления i-ой консоли в системе координат, связанной с консолью (отсчитываемая от оси фюзеляжа вдоль размаха консоли)
                z_dc_I_i = self.consolesI[i].z_d(self.fuselage, M_I, alpha_c_i, H = H, xx_t = xx_t_I, T_s = T_s)
                # Коэффициент нормальной силы (по нормали к консоли, если консоль статичная или полностью поворотная), понадобятся позже для расчёта скоса потока
                c_nc_I[i] = self.consolesI[i].c_n_P(self.fuselage, M_I, alpha_c_i, H = H)
            else:
                # Коэффициент продольной силы i-ой консоли в системе координат, связанной с консолью с учётом коэфф. торможения и приведения к единой характерной площади S летательного аппарата
                c_xс_I_i = self.consolesI[i].c_x(self.fuselage, M_I, alpha_c_i, delta=delta_I[i], H = H, xx_t = xx_t_I, T_s = T_s) * kM_I * self.consolesI[i].S_1c /  self.S
                # Коэффициент нормальной силы i-ой консоли в системе координат, связанной с консолью с учётом коэфф. торможения и приведения к единой характерной площади S летательного аппарата
                c_yc_I_i = self.consolesI[i].c_y(self.fuselage, M_I, alpha_c_i, delta=delta_I[i], H = H, xx_t = xx_t_I, T_s = T_s) * kM_I * self.consolesI[i].S_1c /  self.S
                # Координата x центра давления i-ой консоли в системе координат, связанной с консолью (отсчитываемая от носа фюзеляжа)
                x_dc_I_i = self.consolesI[i].x_d(self.fuselage, M_I, alpha_c_i, delta=delta_I[i], H = H, xx_t = xx_t_I, T_s = T_s)
                # Координата z центра давления i-ой консоли в системе координат, связанной с консолью (отсчитываемая от оси фюзеляжа вдоль размаха консоли)
                z_dc_I_i = self.consolesI[i].z_d(self.fuselage, M_I, alpha_c_i, delta=delta_I[i], H = H, xx_t = xx_t_I, T_s = T_s)
                # Коэффициент нормальной силы (по нормали к консоли, если консоль статичная или полностью поворотная), понадобятся позже для расчёта скоса потока
                c_nc_I[i] = self.consolesI[i].c_n_P(self.fuselage, M_I, alpha_c_i, delta=delta_I[i], H = H)


            # Коэффициент продольной силы i-ой консоли в проекции на связанную ось Ox летательного аппарата совпадает с c_xс_I_i
            # поскольку продольные оси консоли и ЛА направлены параллельно
            c_x_I_i = c_xс_I_i
            # Коэффициент нормальной силы i-ой консоли в проекции на связанную ось Oy летательного аппарата
            c_y_I_i = c_yc_I_i * cos(self.consolesI[i].psi)
            # Коэффициент нормальной силы i-ой консоли в проекции на связанную ось Oz летательного аппарата
            # поскольку при повороте консолей на угол psi против часовой стрелки их нормальная ось получается направлена противоположна от Oz ЛА, нужно поставить знак минус
            c_z_I_i = - c_yc_I_i * sin(self.consolesI[i].psi)
            # Координата x центра давления i-ой консоли в проекции на связанную ось Ox летательного аппарата совпадает с x_dc_I_i
            # поскольку продольные оси консоли и ЛА направлены параллельно
            x_d_I_i = x_dc_I_i
            # Координата z центра давления i-ой консоли в проекции на связанную ось Oy летательного аппарата
            y_d_I_i = z_dc_I_i * sin(self.consolesI[i].psi)
            # Координата z центра давления i-ой консоли в проекции на связанную ось Oz летательного аппарата
            z_d_I_i = z_dc_I_i * cos(self.consolesI[i].psi)

            # Суммируем коэффициенты сил консолей
            c_x_I = c_x_I + c_x_I_i            
            c_y_I = c_y_I + c_y_I_i
            c_z_I = c_z_I + c_z_I_i
            # Суммируем моменты от сил консолей (с учётом приведения коэффициента момента к характерной длине ЛА L)
            m_x_I = m_x_I  +  (- c_y_I_i * z_d_I_i  +  c_z_I_i * y_d_I_i) / self.L
            m_y_I = m_y_I  +  ( - c_z_I_i * (x_0 - x_d_I_i) / self.L)
            m_z_I = m_z_I  +  c_y_I_i * (x_0 - x_d_I_i) / self.L






        # Второй пояс консолей (если он есть) рассчитывается аналогично
        # Коэффициенты продольных сил консолей, установленных на фюзеляж, следует просуммировать
        # Коэффициенты нормальной силы консолей, установленных на фюзеляж, определяются в плоскости нормальной к статичной части консоли,
        # поэтому угол атаки и нормальную силу нужно спроецировать в зависимости от поперечного угла установки каждой консоли        
        c_x_II = 0
        c_y_II = 0
        c_z_II = 0
        # Коэффициенты моментов получаются как сумма моментов от проекций силы каждой консоли
        m_x_II = 0
        m_y_II = 0
        m_z_II = 0

        # Вторая несущая поверхность всегда расположена в полностью турбулентном пограничном слое, поэтому
        xx_t_II = 0

        if self.consolesII is not None:
            for i in range(len(self.consolesII)):
                # Поперечный угол установки консоли по отношению к плоскости пространственного угла атаки
                psi_alpha_i = self.consolesII[i].psi - phi_alpha
                # Угол атаки, под которым получается установлена статичная часть i-ой консоли по отношению к набегающему потоку без учёта скоса потока
                alpha_c_geom_i = alpha * cos(psi_alpha_i)
                
                # Для определения коэффициента торможения потока, набегающего на данную консоль, необходимо найти ближайшую (по углу psi) консоль из I пояса,
                # за которой и в чьём конусе Маха находится данная консоль, для этого перебираем передние консоли и находим ту, разница углов psi с которой минимальная
                i_cI = 0 #индекс ближайшей консоли
                Delta_psi_min = abs(self.consolesI[0].psi - self.consolesII[i].psi)
                for i_I in range(len(self.consolesI)):
                    Delta_psi = abs(self.consolesI[i_I].psi - self.consolesII[i].psi)
                    if Delta_psi < Delta_psi_min:
                        Delta_psi_min = Delta_psi
                        i_cI = i_I

                
                # Задняя консоль обтекается заторможенным потоком только если находится внутри конуса Маха возмущений создаваемых передней консолью,
                # для приблизительной проверки того что задняя консоль находится в конусе Маха используем библиотечную функцию для расчёта множителя скоса потока,
                # которая возвращает отношение площади задней консоли попавшей внутрь конуса Маха к всей площади консоли
                # если это отношение не нулевое, то считаем что задняя консоль находится в зоне влияния передней консоли и обтекается заторможенным потоком
                # так же, значение этого множителя в дальнейшем понадобится для расчёта угла скоса потока
                
                # Расстояние от конца САХ передней консоли до середины САХ задней консоли
                x_I_II = (self.consolesII[i].x_b + self.consolesII[i].IsP.x_A + 0.5 * self.consolesII[i].IsP.b_A) - (self.consolesI[i_cI].x_b + self.consolesI[i_cI].IsP.x_A + self.consolesI[i_cI].IsP.b_A)
                
                # Вызываем библиотечную функцию для расчёта относительной координаты z точки схода вихря (вдоль размаха передней консоли)
                zz_v = AeroBDSM.get_Coordinate_zz_v(M_I, self.consolesI[i_cI].IsP.lambd, self.consolesI[i_cI].IsP.chi_05, self.consolesI[i_cI].IsP.zeta).Value
                # Координата z точки схода вихря (вдоль размаха передней консоли)
                z_v = self.fuselage.D / 2 + zz_v * self.consolesI[i_cI].l_1c                    
                # Координата y точки схода вихря (по нормали к задней кромке передней консоли)
                y_v = x_I_II * sin(alpha_c_geom_i) #это допущение не учитывающее возможного поворота консоли и чего-нибудь ещё?
                # Координата x точки схода вихря (находится на задней кромке передней консоли)
                x_v = self.consolesI[i_cI].x_b + self.consolesI[i_cI].IsP.b_b + (z_v - self.fuselage.D / 2) * tan(self.consolesI[i_cI].IsP.chi_1)
                # Расстояние вдоль оси x от точки схода вихря до начала бортовой хорды задней консоли
                x_vI_bII = self.consolesII[i].x_b - x_v

                # Поперечный угол между рассматриваемой передней и задней консолью
                Delta_psi = abs(self.consolesI[i_cI].psi - self.consolesII[i].psi) #какое правило знаков у этого угла? пока поставил модуль
                # Диаметр фюзеляжа в районе задних консолей
                D_II = self.fuselage.D

                psi_epsilon = AeroBDSM.get_psi_eps(M_I, z_v, y_v, x_vI_bII, Delta_psi, D_II, self.consolesII[i].l_1c, self.consolesII[i].IsP.eta, self.consolesII[i].IsP.b_b, self.consolesII[i].IsP.chi_0).Value    
                
                # Коэффициент торможения потока
                kM_II_i = kM_I
                # Число Маха потока набегающего на II консоли, с учётом торможения                
                M_II_i = M_I

                if psi_epsilon > 0:                    
                    # Вызываем библиотечную функцию для определения коэффициента торможения потока за несущей поверхностью 
                    kM_P = AeroBDSM.get_kM_P(M_I, x_I_II, self.consolesI[i_cI].IsP.b_A) # здесь надо M_I использовать? В ЛиЧе явно не указано
                    # Коэффициент торможения, скорректированный под площади данных консолей и с учётом торможения потока в носовом скачке уплотнения
                    kM_II_i = kM_I * (kM_P + self.consolesII[i].S_1c / self.consolesI[i_cI].S_1c) / (1 + self.consolesII[i].S_1c / self.consolesI[i_cI].S_1c)
                    # Число Маха потока набегающего на II консоли, с учётом торможения                
                    M_II_i = M * kM_II_i
                
                
                
                # Передняя консоль может вызывать скос потока набегающего на заднюю консоль (если она попадает в конус Маха), поэтому угол атаки задней консоли уменьшается на средний (по размаху) угол скоса потока
                epsilon_m = 0
                if psi_epsilon > 0:
                    # Вычисляем коэффициенты интерференции консоли с фюзеляжем
                    k_alpha_alpha_II_i, K_alpha_alpha_II_i, k_delta0_II_i, K_delta0_II_i = self.consolesII[i].InterferenceCoefs(self.fuselage, M_II_i, H)                    

                    # Вызываем библиотечную функцию для определения коэффициента интерференции передней и задней консоли
                    interference_v = AeroBDSM.get_interference_v(self.consolesII[i].IsP.zeta, D_II, self.consolesII[i].IsP.l, abs(y_v), z_v).Value
                    # Средний угол скоса потока
                    epsilon_m = (interference_v * self.consolesI[i_cI].l_1c * c_nc_I[i_cI] * (self.S / self.consolesI[i_cI].S_1c) * psi_epsilon) / (2 * pi * zz_v * self.consolesII[i].l_1c * self.consolesI[i_cI].IsP.lambd * K_alpha_alpha_II_i)

                
                # Угол атаки, под которым получается установлена статичная часть i-ой консоли по отношению к набегающему потоку с учётом скоса потока
                alpha_c_i = alpha_c_geom_i - epsilon_m
                
                if delta_II is None:
                    # Коэффициент продольной силы i-ой консоли в системе координат, связанной с консолью с учётом коэфф. торможения и приведения к единой характерной площади S летательного аппарата
                    c_xс_II_i = self.consolesII[i].c_x(self.fuselage, M_II_i, alpha_c_i, H = H, xx_t = xx_t_II, T_s = T_s) * kM_II_i * self.consolesII[i].S_1c /  self.S
                    # Коэффициент нормальной силы i-ой консоли в системе координат, связанной с консолью с учётом коэфф. торможения и приведения к единой характерной площади S летательного аппарата
                    c_yс_II_i = self.consolesII[i].c_y(self.fuselage, M_II_i, alpha_c_i, H = H, xx_t = xx_t_II, T_s = T_s) * kM_II_i * self.consolesII[i].S_1c /  self.S
                    # Координата x центра давления i-ой консоли в системе координат, связанной с консолью (отсчитываемая от носа фюзеляжа)
                    x_dc_II_i = self.consolesII[i].x_d(self.fuselage, M_II_i, alpha_c_i, H = H, xx_t = xx_t_II, T_s = T_s)
                    # Координата z центра давления i-ой консоли в системе координат, связанной с консолью (отсчитываемая от оси фюзеляжа вдоль размаха консоли)
                    z_dc_II_i = self.consolesII[i].z_d(self.fuselage, M_II_i, alpha_c_i, H = H, xx_t = xx_t_II, T_s = T_s)
                else:
                    # Коэффициент продольной силы i-ой консоли в системе координат, связанной с консолью с учётом коэфф. торможения и приведения к единой характерной площади S летательного аппарата
                    c_xс_II_i = self.consolesII[i].c_x(self.fuselage, M_II_i, alpha_c_i, delta=delta_II[i], H = H, xx_t = xx_t_II, T_s = T_s) * kM_II_i * self.consolesII[i].S_1c /  self.S
                    # Коэффициент нормальной силы i-ой консоли в системе координат, связанной с консолью с учётом коэфф. торможения и приведения к единой характерной площади S летательного аппарата
                    c_yс_II_i = self.consolesII[i].c_y(self.fuselage, M_II_i, alpha_c_i, delta=delta_II[i], H = H, xx_t = xx_t_II, T_s = T_s) * kM_II_i * self.consolesII[i].S_1c /  self.S
                    # Координата x центра давления i-ой консоли в системе координат, связанной с консолью (отсчитываемая от носа фюзеляжа)
                    x_dc_II_i = self.consolesII[i].x_d(self.fuselage, M_II_i, alpha_c_i, delta=delta_II[i], H = H, xx_t = xx_t_II, T_s = T_s)
                    # Координата z центра давления i-ой консоли в системе координат, связанной с консолью (отсчитываемая от оси фюзеляжа вдоль размаха консоли)
                    z_dc_II_i = self.consolesII[i].z_d(self.fuselage, M_II_i, alpha_c_i, delta=delta_II[i], H = H, xx_t = xx_t_II, T_s = T_s)

                # Коэффициент продольной силы i-ой консоли в проекции на связанную ось Ox летательного аппарата совпадает с c_xс_II_i
                # поскольку продольные оси консоли и ЛА направлены параллельно
                c_x_II_i = c_xс_II_i
                # Коэффициент нормальной силы i-ой консоли в проекции на связанную ось Oy летательного аппарата
                c_y_II_i = c_yс_II_i * cos(self.consolesII[i].psi)
                # Коэффициент нормальной силы i-ой консоли в проекции на связанную ось Oz летательного аппарата
                # поскольку при повороте консолей на угол psi против часовой стрелки их нормальная ось получается направлена противоположна от Oz ЛА, нужно поставить знак минус
                c_z_II_i = - c_yс_II_i * sin(self.consolesII[i].psi)
                # Координата x центра давления i-ой консоли в проекции на связанную ось Ox летательного аппарата совпадает с x_dc_II_i
                # поскольку продольные оси консоли и ЛА направлены параллельно
                x_d_II_i = x_dc_II_i
                # Координата z центра давления i-ой консоли в проекции на связанную ось Oy летательного аппарата
                y_d_II_i = z_dc_II_i * sin(self.consolesII[i].psi)
                # Координата z центра давления i-ой консоли в проекции на связанную ось Oz летательного аппарата
                z_d_II_i = z_dc_II_i * cos(self.consolesII[i].psi)

                # Суммируем коэффициенты сил консолей
                c_x_II = c_x_II + c_x_II_i            
                c_y_II = c_y_II + c_y_II_i
                c_z_II = c_z_II + c_z_II_i
                # Суммируем моменты от сил консолей (с учётом приведения коэффициента момента к характерной длине ЛА L)
                m_x_II = m_x_II  +  (- c_y_II_i * z_d_II_i  +  c_z_II_i * y_d_II_i) / self.L
                m_y_II = m_y_II  +  ( - c_z_II_i * (x_0 - x_d_II_i) / self.L)
                m_z_II = m_z_II  +  c_y_II_i * (x_0 - x_d_II_i) / self.L
        
                
        # Суммируем составляющие от фюзеляжа, передних консолей и задних консолей
        c_x = c_x_F + c_x_I + c_x_II
        c_y = c_y_F + c_y_I + c_y_II
        c_z = c_z_F + c_z_I + c_z_II

        m_x = m_x_F + m_x_I + m_x_II
        m_y = m_y_F + m_y_I + m_y_II
        m_z = m_z_F + m_z_I + m_z_II

        # Координаты центра давления ЛА (от носа фюзеляжа)
        x_d = x_0 + sqrt(m_z**2 + m_y**2) * self.L / sqrt(c_y**2 + c_z**2)        
       
        return c_x, c_y, c_z, m_x, m_y, m_z, x_d