from libs import AeroBDSM
from libs.handler import *
from math import *
from numpy import sign
from typing import Dict
from .__Isolated_Plane import IsolatedPlane
from .profiles.__Profile import Profile

class IsolatedPlane_RotatingConsoles(IsolatedPlane):
    '''
    Класс расчета АДХ изолированного поворотного крыла конечного размаха

    Функции:
   
    '''

    def __init__(self, S: float, lambd: float, zeta: float, chi_05: float, S_r: float, lambd_r: float, xx_r: float, profile: Profile) -> None:
        '''
        Создание полей объекта класса и расчет геометрических параметров изолированного крыла с поворотными консолями

        Ввод:   S: float - площадь крыла в плане, м^2
                lambd: float - удлинение крыла
                zeta: float - обратное сужение крыла
                chi_05: float - угол стреловидности по линии середин хорд, рад
                S_r: float - площадь рулей, м^2 ?переделать на l_r/l
                lambd_r: float - удлинение рулей
                xx_r: float - относительная координата оси вращения рулей (в долях длины поворотной хорды)
                profile: Profile - объект класса профиля крыла
        Вывод:  ...
        '''

        super().__init__(S, lambd, zeta, chi_05, profile)

        self.IsP = IsolatedPlane(S, lambd, zeta, chi_05, profile)

        # Проверка корректности заданных геометрических параметров
        assert all(map(lambda x: x >= 0, [S_r, lambd_r, xx_r])), 'Величины должны быть положительные'

        # Проверка корректности заданной площади рулей
        assert S >= S_r, 'Площадь рулей не может быть больше площади крыла'
            
        # Проверка корректного расположения оси вращения рулей
        assert 0 <= xx_r <= 1, 'Ось не может лежать вне поворотной хорды рулей'
                
        self.xx_r = xx_r                                                                                # Относительная координата оси вращения рулей (в долях поворотной хорды)
        self.x_r = self.xx_r * self.b_b                                                                 # Координата оси вращения рулей от бортовой хорды рулей
        self.S_r = S_r                                                                                  # Площадь рулей
        self.lambd_r = lambd_r                                                                          # Удлинение рулей
        self.l_r = sqrt(self.S_r * self.lambd_r)                                                        # Размах рулей
        self.b_r = 2 * self.S_r / self.l_r - self.b_1                                                   # Хорда рулей
        self.eta_r = self.b_r / self.b_1                                                                # Сужение рулей
        self.zeta_r = 1 / self.eta_r                                                                    # Обратное сужение рулей
        self.b_Ar = 4 / 3 * self.S_r / self.l_r * (1 - self.eta_r / (self.eta_r + 1) ** 2)              # САХ рулей
        self.z_Ar = self.l_r / 6 * (self.eta_r + 2) / (self.eta_r + 1)                                  # Расстояние между хордой и САХ рулей
        self.x_Ar = self.z_Ar * tan(self.chi_0)                                                         # Координата начала САХ рулей
        self.x_tr = self.x_Ar + self.b_Ar / 2                                                           # Координата центра тяжести рулей
        self.l_p = self.l - self.l_r                                                                    # Размах статичной части крыла
        
        if self.l_p == 0: #?что это значит?#
            self.l_p = None                                                                             # Размах статичной части крыла
            self.S_p = None                                                                             # Площадь статичной части крыла
            self.lambda_p = None                                                                        # Удлинение статичной части крыла
            self.eta_p = None                                                                           # Сужение статичной части крыла
            self.zeta_p = None                                                                          # Обратное сужение статичной части крыла
            self.b_Ap = None                                                                            # САХ статичной части крыла
            self.z_Ap = None                                                                            # Расстояние между хордой и САХ статичной части крыла
            self.x_Ap = None                                                                            # Координата начала САХ статичной части крыла
            self.x_tp = None                                                                            # Координата центра тяжести статической части крыла

        else:
            self.S_p = self.S - self.S_r                                                                # Площадь статичной части крыла
            self.lambda_p = self.l_p ** 2 / self.S_p                                                    # Удлинение статичной части крыла
            self.eta_p = self.b_b / self.b_r                                                            # Сужение статичной части крыла
            self.zeta_p = 1 / self.eta_p                                                                # Обратное сужение статичной части крыла
            self.b_Ap = 4 / 3 * self.S_p / self.l_p * (1 - self.eta_p / (self.eta_p + 1) ** 2)          # САХ статичной части крыла
            self.z_Ap = self.l_p / 6 * (self.eta_p + 2) / (self.eta_p + 1)                              # Расстояние между хордой и САХ статичной части крыла
            self.x_Ap = self.z_Ap * tan(self.chi_0)                                                     # Координата начала САХ статичной части крыла
            self.x_tp = self.x_Ap + self.b_Ap / 2                                                       # Координата центра тяжести статической части крыла
       
    @checkSavedValue
    def n_eff(self, M: float, *args) -> float:
        '''
        Расчет эффективности рулей

        Ввод:   M: float - число Маха
        Вывод:  n_eff: float - эффективность рулей
        '''
        
        # Вызываем библиотечную функцию для определения коэффициента учета потерь нормальной силы за счет перетекания воздуха через щели
        k_sch = AeroBDSM.get_k_sch(M)

        # Вызываем библиотечную функцию для определения коэффициента,
        # характеризующего относительную эффективность концевых рулей без учета потерь от перетекания воздуха через щель
        nn_1 = AeroBDSM.get_nn_Eff1(self.l_r, self.l, self.zeta).Value
    
        # Эффективность рулей
        n_eff = k_sch * nn_1

        # Результат
        return n_eff
    
    @checkSavedValue
    def alpha_eff(self, M: float, alpha: float, delta: float) -> float:
        '''
        Расчет эффективного угла атаки
        (угол, под которым должно было бы стоять крыло целиком,
        чтобы создавать такие же силы как если статичная часть консоли находится под углом alpha,
        а поворотная часть отклонена от неё на угол delta)
        
        Ввод:   M: float - число Маха
                alpha: float - угол атаки статичной части, рад
                delta: float - угол отклонения рулей, рад
        Вывод:  alpha_eff: float - эффективный угол атаки, рад
        '''

        # Относительная эффективность рулей
        n_eff = self.n_eff(M)

        # Эффективный угол атаки
        alpha_eff = alpha + n_eff * delta

        # Результат
        return alpha_eff

    @checkSavedValue
    def c_y(self, M: float, alpha: float, delta: float, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчет коэффициента нормальной силы
        (нормальной к статичной части крыла)

        Ввод:   M: float - число Маха
                alpha: float - угол атаки статичной части крыла, рад
                delta: float - угол отклонения рулей, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности крыла, К
        Вывод:  c_y: float - коэффициент нормальной силы (нормальной к статичной части крыла)
        '''

        # Эффективный угол атаки
        alpha_eff = self.alpha_eff(M, alpha, delta)
        
        # Коэффициент нормальной силы цельного крыла при угле атаки alpha_eff
        c_n = self.IsP.c_y(M, alpha_eff)       #как направлена эта сила? под углом альфа_эфф или альфа, предполагаем что альфа_эфф
    
        # Коэффициент продольной силы цельного крыла при угле атаки alpha_eff
        c_tau = self.IsP.c_x(M, alpha_eff, H, xx_t, T_s) #как направлена эта сила? под углом альфа_эфф или альфа, предполагаем что альфа_эфф

        # Поскольку мы хотим получить коэффициент силы нормальной к статичной части крыла, стоящей под углом alpha, а не alpha_eff, то
        c_y = c_n * cos(alpha_eff - alpha) - c_tau * sin(alpha_eff - alpha)

        # Результат
        return c_y
    
    @checkSavedValue
    def c_xa(self, M: float, alpha: float, delta: float, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчет коэффициента силы лобового сопротивления

        Ввод:   M: float - число Маха
                alpha: float - угол атаки статичной части крыла, рад
                delta: float - угол отклонения рулей, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности крыла, К
        Вывод:  c_xa: float - коэффициент силы лобового сопротивления
        '''

        # Эффективный угол атаки
        alpha_eff = self.alpha_eff(M, alpha, delta)

        # Критическое число Маха при эффективном угле атаки
        M_cr = self.IsP.M_cr(M, alpha_eff)

        # Коэффициент силы лобового сопротивления крыла при нулевом угле атаки и отклонения рулей
        c_xa0 = self.IsP.c_xa0(M, M_cr, H, xx_t, T_s)

        # Коэффициент индуктивного сопротивления
        c_xai = self.IsP.c_xai(M, alpha_eff)

        # Коэффициент силы лобового сопротивления крыла
        c_xa = c_xa0 + c_xai

        # Результат
        return c_xa

    @checkSavedValue
    def c_ya(self, M: float, alpha: float, delta: float, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчет коэффициента подъемной силы

        Ввод:   M: float - число Маха
                alpha: float - угол атаки статичной части крыла, рад
                delta: float - угол отклонения рулей, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности крыла, К
        Вывод:  c_ya: float - коэффициент подъемной силы
        '''

        # Коэффициент подъемной силы крыла
        c_y = self.c_y(M, alpha, delta)
        
        # Коэффициент силы лобового сопротивления крыла
        c_xa = self.c_xa(M, alpha, delta, H, xx_t, T_s)       

        # Поскольку c_y направлен по нормали к статичной части крыла, стоящей под углом alpha,
        # а c_xa направлен вдоль потока, то проецируем используя угол alpha статичной части
        # Коэффициент подъёмной силы крыла
        c_ya = (c_y - c_xa * sin(alpha)) / cos(alpha)

        # Результат
        return c_ya

    @checkSavedValue
    def c_x(self, M: float, alpha: float, delta: float, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчет коэффициента продольной силы
        (направленной вдоль статичной части крыла)

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
                delta: float - угол отклонения рулей, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности крыла, К
        Вывод:  c_x: float - коэффициент продольной силы (направленной вдоль статичной части крыла)
        '''
        # Эффективный угол атаки
        alpha_eff = self.alpha_eff(M, alpha, delta)
        
        # Коэффициент нормальной силы крыла
        c_y = self.c_y(M, alpha, delta)        

        # Коэффициент силы лобового сопротивления
        c_xa = self.c_xa(M, alpha, delta, H, xx_t, T_s)

        # Поскольку c_y направлен по нормали к статичной части крыла, стоящей под углом alpha,
        # а c_xa направлен вдоль потока, то проецируем используя угол alpha статичной части
        # Коэффициент продольной силы крыла
        c_x = (c_xa - c_y * sin(alpha_eff)) / cos(alpha_eff)

        # Результат
        return c_x

    @checkSavedValue
    def x_d(self, M: float, alpha: float, delta: float, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчет продольной координаты центра давления

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
                delta: float - угол отклонения рулей, рад                
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности крыла, К
        Вывод:  x_d: float - продольная координата центра давления изолированного крыла, отсчитываемая от носка бортовой хорды, м
        '''
        
        # Эффективный угол атаки
        alpha_eff = self.alpha_eff(M, alpha, delta)
        
        # Коэффициент нормальной силы цельного крыла при угле атаки alpha_eff
        c_n = self.IsP.c_y(M, alpha_eff)       #как направлена эта сила? под углом альфа_эфф или альфа, предполагаем что альфа_эфф

        # Эта сила приложена в центре давления цельного крыла, установленного под углом атаки alpha_eff
        x_dn = self.IsP.x_d(M, alpha_eff)
        
        # Коэффициент продольной силы цельного крыла при угле атаки alpha_eff
        c_tau = self.IsP.c_x(M, alpha, H, xx_t, T_s) #как направлена эта сила? под углом альфа_эфф или альфа, предполагаем что альфа_эфф
        #считаем, что эта сила приложена в координате оси вращения

        # Коэффициент силы нормальной к статичной части крыла
        c_y = self.c_y(M, alpha, delta, H, xx_t, T_s)

        # Координата фокуса крыла
        x_F_alpha = self.IsP.x_F_alpha(M)  
        
        if c_y == 0:
            #При нулевой подъёмной силе центр давления отсутствует, условно принимаем что центр давления совпадает с фокусом
            return x_F_alpha        
        else:
            # Так как мы ищем точку приложения результирующей силы (от c_n и c_tau) нормальной к статичной части крыла,
            # определяем эту точку таким образом, чтобы момент от результирующей силы, равнялся моменту от пары этих сил,
            # спроецированных на нормаль к статичной части крыла
            x_d = (c_n * cos(alpha_eff - alpha) * x_dn - c_tau * sin(alpha_eff - alpha) * self.x_r) / c_y            
            
        # Результат
        return x_d
    
    @checkSavedValue
    def z_dc(self, M: float, alpha: float, delta: float) -> float:
        '''
        Расчет поперечной координаты центра давления консоли

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
                delta: float - угол отклонения рулей, рад                
        Вывод:  z_dc: float - поперечная координата центра давления консоли (отсчитываемая от бортовой хорды), м
        '''
        
        # Эффективный угол атаки
        alpha_eff = self.alpha_eff(M, alpha, delta)
        
        z_dc = self.IsP.z_dc(M, alpha_eff)
            
        # Результат
        return z_dc

    @checkSavedValue
    def m_z(self, M: float, alpha: float, delta: float, xx_0: float, omega_z: float = 0, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчет коэффициента продольного момента

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
                delta: float - угол отклонения рулей, рад        
                xx_0: float - относительная координата центра вращения в долях САХ (от носка САХ) 
                omega_z: float - угловая скорость вращения крыла вокруг оси Оz, рад/с
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности крыла, К
        Вывод:  m_z: float - коэффициент продольного момента
        '''
        
        # Координата центра давления
        x_d = self.x_d(M, alpha, delta, H, xx_t, T_s)

        # Координата центра вращения
        x_0 = self.x_A + self.b_A * xx_0

        # Коэффициент продольного демпфирующего момента крыла
        m_z_omega_z = self.IsP.m_z_omega_z(M, xx_0)

        # Безразмерная угловая скорость
        omega_omega_z = omega_z * self.b_A / Mach_to_v(M, H)

        # Коэффициент продольного момента крыла
        m_z = self.c_y(M, alpha, delta, H, xx_t, T_s) * (x_0 - x_d) / self.b_A + m_z_omega_z * omega_omega_z

        # Результат
        return m_z
    
    def geometry(self) -> Dict:
        '''
        Вывод геометрических параметров изолированного крыла с концевыми рулями

        Ввод:   ...
        Вывод:  plane_type: str - тип крыла [-]
                b_1: float - концевая хорда крыла [м]
                b_0: float - длина хорды крыла (без учета затупления задней кромки) [м]
                b_A: float - САХ (средняя аэродинамическая хорда) крыла [м]
                b_Ap: float - САХ (средняя аэродинамическая хорда) статичной части крыла [м]
                b_Ar: float - САХ (средняя аэродинамическая хорда) рулей [м]
                b_b: float - бортовая хорда крыла [м]
                b_r: float - хорда рулей [м]
                chi_0: float - угол стреловидности по передней кромке крыла [рад]
                chi_05: float - угол стреловидности по линии середин хорд крыла [рад]
                chi_1: float - угол стреловидности по задней кромке крыла [рад]
                chi_c: float - угол стреловидности по линии максимальных толщин крыла [рад]
                chi_r: float - угол наклона оси вращения рулей [рад]
                eta: float - сужение крыла [-]
                eta_p: float - сужение статичной части крыла [-]
                eta_r: float - сужение рулей [-]
                l: float - размах крыла [м]
                l_p: float - размах статичной части крыла [м]
                l_r: float - размах рулей [м]
                lambd: float - относительное удлинение крыла [-]
                lambda_p: float - относительное удлинение статичной части крыла [-]
                lambda_r: float - относительное удлинение рулей [-]
                S: float - площадь крыла [м^2]
                S_p: float - площадь статичной части крыла [м^2]
                S_r: float - площадь рулей [м^2]
                x_A: float - координата начала САХ (средней аэродинамической хорды) крыла от носка бортовой хорды [м]
                x_Ap: float - координата начала САХ (средней аэродинамической хорды) статичной части крыла от носка бортовой хорды [м]
                x_Ar: float - координата начала САХ (средней аэродинамической хорды) рулей от носка хорды рулей [м]
                x_r: float - координата оси вращения рулей от бортовой хорды рулей [м]
                x_t: float - координата центра тяжести крыла от носка бортовой хорды [м]
                x_tp: float - координата центра тяжести статической части крыла от носка носка бортовой хорды [м]
                x_tr: float - координата центра тяжести рулей от носка хорды рулей [м]
                xx_r: float - относительная координата оси вращения рулей [-]
                z_A: float - расстояние между САХ (средней аэродинамической хордой) и бортовой хордой крыла [м]
                z_Ap: float - расстояние между САХ (средней аэродинамической хордой) статичной части и бортовой хордой крыла [м]
                z_Ar: float - расстояние между САХ (средней аэродинамической хордой) рулей и хордой рулей [м]
                zeta: float - обратное сужение крыла [-]
                zeta_p: float - обратное сужение статичной части крыла [-]
                zeta_r: float - обратное сужение рулей [-]
        '''

        # Результат
        result = {
            'cons_type': 'полноповоротное крыло',
            'b_1': self.b_1,
            'b_A': self.b_A,
            'b_Ap': self.b_Ap,
            'b_Ar': self.b_Ar,
            'b_b': self.b_b,
            'chi_0': degrees(self.chi_0),
            'chi_05': degrees(self.chi_05),
            'chi_1': degrees(self.chi_1),
            'chi_c': degrees(self.chi_c),
            'chi_r': self.chi_r,
            'eta': self.eta,
            'eta_p': self.eta_p,
            'eta_r': self.eta_r,
            'l': self.l,
            'l_p': self.l_p,
            'l_r': self.l_r,
            'lambd': self.lambd,
            'lambda_p': self.lambda_p,
            'lambda_r': self.lambda_r,
            'S': self.S,
            'S_p': self.S_p,
            'S_r': self.S_r,
            'x_A': self.x_A,
            'x_Ap': self.x_Ap,
            'x_Ar': self.x_Ar,
            'x_r': self.x_r,
            'x_t': self.x_t,
            'x_tp': self.x_tp,
            'x_tr': self.x_tr,
            'xx_r': self.xx_r,
            'z_A': self.z_A,
            'z_Ap': self.z_Ap,
            'z_Ar': self.z_Ar,
            'zeta': self.zeta,
            'zeta_p': self.zeta_p,
            'zeta_r': self.zeta_r
            }

        # Результат
        return result



  