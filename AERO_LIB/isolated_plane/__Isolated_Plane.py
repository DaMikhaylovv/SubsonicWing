from libs import AeroBDSM
from libs.Atmosphere import atmo
from libs.handler import *
from math import *
from numpy import sign
from typing import Dict
from .profiles.__Profile import Profile

class IsolatedPlane:   
    '''
    Класс расчета АДХ изолированного монопланного крыла конечного размаха

    Функции:
    
    '''
    
    def __init__(self, S: float, lambd: float, zeta: float, chi_05: float, profile: Profile) -> None:
        '''
        Создание полей объекта класса и расчет геометрических параметров изолированного крыла

        Ввод:   S: float - площадь крыла в плане, м^2
                lambd: float - удлинение крыла
                zeta: float - обратное сужение крыла
                chi_05: float - угол стреловидности по линии середин хорд, рад                
                profile: Profile - объект класса профиля крыла
        Вывод:  ...
        '''

        # Проверка корректности заданных геометрических параметров крыла
        assert all(map(lambda x: x >= 0, [S, lambd, zeta, chi_05])), 'Величины должны быть положительные'

        self.S = S                                                                                              # Площадь крыла
        self.lambd = lambd                                                                                      # Удлинение крыла
        self.l = sqrt(self.S * self.lambd)                                                                      # Размах крыла
        self.zeta = zeta                                                                                        # Обратное сужение крыла
        self.eta = 1 / self.zeta                                                                                # Сужение крыла
        self.b_b = self.S / self.l * 2 * self.eta / (self.eta + 1)                                              # Бортовая хорда крыла
        self.b_1 = self.b_b / self.eta                                                                          # Концевая хорда крыла
        self.b_A = 4 / 3 * self.S / self.l * (1 - self.eta / (self.eta + 1) ** 2)                               # САХ (средняя аэродинамическая хорда) крыла
        self.z_A = self.l / 6 * (self.eta + 2) / (self.eta + 1)                                                 # Расстояние между бортовой хордой и САХ крыла
        self.chi_05 = chi_05                                                                                    # Угол стреловидности по линии середин хорд
        self.chi_0 = atan(tan(self.chi_05) + 2 / self.lambd * (self.eta - 1) / (self.eta + 1))                  # Угол стреловидности по передней кромке
        self.chi_1 = atan(tan(self.chi_0) - 4 / self.lambd * (self.eta - 1) / (self.eta + 1))                   # Угол стреловидности по задней кромке
        self.x_A = self.z_A * tan(self.chi_0)                                                                   # Координата начала САХ крыла
        self.x_cS = self.x_A + self.b_A / 2                                                                     # Координата x центра тяжести площади в плане
        self.z_cS = self.z_A                                                                                    # Координата z центра тяжести площади в плане
        self.profile = profile                                                                                  # Профиль крыла
        self.chi_c = atan(self.chi_0 - 4 * self.profile.xx_c / self.lambd * (self.eta - 1) / (self.eta + 1))    # Угол стреловидности по линии максимальных толщин крыла

    @checkSavedValue
    def c_y_alpha(self, M: float) -> float:
        '''
        Расчет производной коэффициента нормальной силы по углу атаки

        Ввод:   M: float - число Маха
        Вывод:  c_y_alpha: float - производная коэффициента нормальной силы по углу атаки, 1/рад
        '''

        # Вызываем библиотечную функцию для определения производной коэффициента нормальной силы крыла по угла атаки
        c_y_alpha = AeroBDSM.get_Cy_alpha_IsP(M, self.lambd, self.profile.cc, self.chi_05, self.eta).Value

        # Результат
        return c_y_alpha

    @checkSavedValue
    def c_y(self, M: float, alpha: float) -> float:
        '''
        Расчет коэффициента нормальной силы

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
        Вывод:  c_y: float - коэффициент нормальной силы
        '''

        # Производная коэффициента нормальной силы крыла по углу атаки
        c_y_alpha = self.c_y_alpha(M)

        # Вызываем библиотечную функцию для определения коэффициента, характеризующего нелинейность коэффициента нормальной силы крыла
        A = AeroBDSM.get_A_IsP(M, self.zeta, c_y_alpha).Value

        # Вычисляем коэффициент нормальной силы крыла
        c_y = c_y_alpha * sin(alpha) * cos(alpha) + A * sin(alpha) ** 2 * sign(alpha)

        # Результат
        return c_y

    @checkSavedValue
    def M_cr(self, M: float, alpha: float) -> float:
        '''
        Расчет критического числа Маха

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
        Вывод:  M_cr: float - критическое число Маха крыла конечного размаха
        '''

        # Коэффициент нормальной силы крыла
        c_y = self.c_y(M, alpha)

        # Критическое число Маха для профиля крыла
        M_cr_pr = self.profile.M_cr(c_y) # правильно ли что тут с_у для крыла, а не для профиля?

        # Критическое число Маха для симметричного дозвукового профиля при коэффициенте нормальной силы консолей, равного нулю
        M_cr_p0 = self.profile.M_cr(0)

        # Вызываем библиотечную функцию для определения поправки к критическому число Маха, учитывающую конечность размаха крыла
        delta_M_cr_lambda = AeroBDSM.get_DELTA_Mcr0_lambda(M_cr_p0, self.lambd).Value

        # Вызываем библиотечную функцию для определения поправки к критическому числу Маха, учитывающую стреловидность крыла
        delta_M_cr_chi = AeroBDSM.get_DELTA_Mcr0_chi(M_cr_p0, self.chi_c).Value

        # Критическое число Маха с учетом поправок на конечность размаха и стреловидность
        M_cr = M_cr_pr + delta_M_cr_lambda + delta_M_cr_chi

        # Результат
        return M_cr
    
    # @checkSavedValue
    def xx_t(self, M: float, H: float, T_s: float = None) -> float:
        '''
        Расчёт относительной координаты точки перехода ламинарного пограничного слоя в турбулентный
        
        Ввод:   M: float - число Маха
                H: float - высота полета, м
                T_s: float - средняя температура поверхности крыла, К

        Вывод:  xx_t: float - координата точки перехода ламинарного пограничного слоя в турбулентный (в долях рассматриваемой хорды)
        '''         
       
        # Относительная высота бугорков шероховатости поверхности
        hh = self.profile.h_s / self.b_A

        # Число Рейнольдса для крыла
        Re = Mach_to_v(M, H) * self.b_A / atmo.nu(H)

        # Вызываем библиотечную функцию для определения критического числа Рейнольдса
        # при отсутствии теплопередачи и нулевом градиенте давления
        Re_t_0_1 = AeroBDSM.get_Re_t0_1(M, Re, hh).Value

        # Вызываем библиотечную функцию для определения поправочного множителя, учитывающего влияние угла стреловидности на критическое число Рейнольдса
        Sigma_chi = AeroBDSM.get_Sigma_chi(self.chi_0).Value

        # Здесь можно ещё ввести поправку на 30-50% при М>1, но от чего зависит её степень, От толщины профиля?
        Re_t_0 = Re_t_0_1 * Sigma_chi
       
        if T_s == None:
            # Средняя температура поверхности считается равной температуре восстановления (теплопередача отсутствует)
            # В этом случае, относительная температура стенки равна 1 (отношение температуры стенки к температуре восстановления)
            TT_s = 1
        else:
            # Задана известная средняя температура поверхности в носовой части фюзеляжа
            # Рассчитываем температуру восстановления            
            # r = 0.845..0.88 - коэффициент восстановления температуры для ламинарного и турбулентного слоя соответственно
            # возьмём усреднённое значение r = 0.865  а какой надо брать то?
            T_r = atmo.T(H) * (1 + (atmo.k - 1) / 2 * 0.865 * M**2)
            # Относительная температура стенки
            TT_s = self.T_s / T_r

        # Вызываем библиотечную функцию для определения поправочного множителя,
        # учитывающего влияние температуры поверхности тела на критическое число Рейнольдса
        Sigma_T = AeroBDSM.get_Sigma_T(M, TT_s).Value
        
        # Критическое число Рейнольдса
        Re_t = Re_t_0 * Sigma_T

        # Вычислим относительную координату точки перехода ламинарного пограничного слоя в турбулентный
        xx_t = Re_t / Re

        #возможно стоит учесть что у дозвуковых профилей при М<Мcr xx_t = xx_c?
         
        return xx_t

    @checkSavedValue
    def c_xa_pr(self, M: float, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчет коэффициента профильного сопротивления ,возможно стоит перенести это в профиль, и xx_t тоже, только тут поправку на chi накладывать?

        Ввод:   M: float - число Маха                
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности крыла, К
        Вывод:  c_xa_p: float - коэффициент профильного сопротивления изолированного крыла
        '''
        
        # Число Рейнольдса крыла
        Re = Mach_to_v(M, H) * self.b_A / atmo.nu(H)

        if xx_t == None:
            #Если координата точки перехода ЛПС в ТПС не задана, то определяем её по критическому числу Рейнольдса
            xx_t = self.xx_t(M, H, T_s)
        
        if T_s == None:
            # Средняя температура носовой части считается равной температуре восстановления (теплопередача отсутствует)
            # Вызываем библиотечную функцию для определения коэффициента трения плоской пластинки при М = 0
            c_f_M0 = AeroBDSM.get_Cf_M0(Re, xx_t).Value
            
            # Вызываем библиотечную функцию для определения поправочного множителя, учитывающего влияние числа Маха на коэффициент трения плоской пластинки
            sigma_M = AeroBDSM.get_Sigma_M(M, xx_t).Value
            
            # Коэффициент трения плоской пластинки с учётом влияния числа Маха
            c_f = c_f_M0 * sigma_M
        else:
            # Задана известная средняя температура поверхности
            # Рассчитываем температуру восстановления            
            # r = 0.845..0.88 - коэффициент восстановления температуры для ламинарного и турбулентного слоя соответственно
            # возьмём усреднённое значение r = 0.865  а какой надо брать то?
            T_r = atmo.T(H) * (1 + (atmo.k - 1) / 2 * 0.865 * M**2)
            # Рассчитываем определяющую температуру 
            T_zv = (atmo.T(H) + T_s) / 2 + 0.22 * (T_r - T_s)
            # Число Рейнольдса, соответствующее определяющей температуре 
            Re_zv = Re / (T_zv / atmo.T(H)**1.76)
            # Вызываем библиотечную функцию для определения коэффициента трения плоской пластинки при М = 0
            c_f_M0 = AeroBDSM.get_Cf_M0(Re_zv, xx_t).Value
            # Вызываем библиотечную функцию для определения поправочного множителя, учитывающего влияние числа Маха на коэффициент трения плоской пластинки
            sigma_M = AeroBDSM.get_Sigma_M(M, xx_t).Value # В ЛиЧ не написано что здесь надо поправку на М?
            
            # Коэффициент трения плоской пластинки с учётом влияния теплопередачи и числа Маха
            c_f = c_f_M0 * atmo.T(H) / T_zv * sigma_M        

        # Вызываем библиотечную функцию для определения поправочного множителя, учитывающего влияние толщины профиля
        Sigma_c = AeroBDSM.get_Sigma_c(self.profile.cc, xx_t).Value

        # Коэффициент профильного сопротивления
        c_xa_p = 2 * c_f * Sigma_c

        # Результат
        return c_xa_p

    @checkSavedValue
    def c_xa_w(self, M: float, M_cr: float) -> float:
        '''
        Расчет коэффициента волнового сопротивления

        Ввод:   M: float - число Маха
                M_cr: float - критическое число Маха
        Вывод:  c_xa_w: float - коэффициент волнового сопротивления
        '''

        # Коэффициент, представляющий собой отношение коэффициента волнового сопротивления рассматриваемого профиля к коэффициенту волнового сопротивления ромбовидного профиля
        K_w = self.profile.K_w()

        # Коэффициент волнового сопротивления
        if M <= M_cr:
            # При дозвуковом обтекании волновое сопротивления отсутствует
            c_xa_w = 0
        elif M >= 1:
            # Вызываем библиотечную функцию для определения множителя, учитывающего степень влияния формы профиля            
            Sigma_pw = AeroBDSM.get_Sigma_pw(M, self.chi_c).Value

            # Вызываем библиотечную функцию для определения коэффициента волнового сопротивления крыла с ромбовидным профилем
            c_xa_w_rhomb = AeroBDSM.get_Cxw_Rhomb_M1(M, self.profile.cc, self.zeta, self.chi_05, self.lambd).Value            

            # Коэффициент волнового сопротивления крыла с данным профилем
            c_xa_w = c_xa_w_rhomb * (1 + Sigma_pw * (K_w - 1)) 
        else:
            # В интервале M_cr < M < 1 волновое сопротивление плавно нарастает, аппроксимируем его полиномом

            # Вызываем библиотечную функцию для определения множителя, учитывающего степень влияния формы профиля при M = 1
            Sigma_pw_M1 = AeroBDSM.get_Sigma_pw(1, self.chi_c).Value

            # Вызываем библиотечную функцию для определения коэффициента волнового сопротивления крыла с ромбовидным профилем при M = 1
            c_xa_w_rhomb_M1 = AeroBDSM.get_Cxw_Rhomb_M1(1, self.profile.cc, self.zeta, self.chi_05, self.lambd).Value

            # Коэффициент волнового сопротивления крыла с данным профилем при M = 1
            c_xa_w_M1 = c_xa_w_rhomb_M1 * (1 + Sigma_pw_M1 * (K_w - 1))

            # Коэффициент полинома `a`
            a_1pol = c_xa_w_M1 / (M_cr ** 2 - 2 * M_cr + 1)
            
            # Коэффициент полинома `b`
            a_2pol = - 2 * a_1pol * M_cr
            
            # Коэффициент полинома `c`
            a_3pol = c_xa_w_M1 - a_1pol * (1 - 2 * M_cr)
            
            # Коэффициент волнового сопротивления крыла
            c_xa_w = a_1pol * M ** 2 + a_2pol * M + a_3pol   

       
       
        # Результат
        return c_xa_w
    
    @checkSavedValue
    def c_xa0(self, M: float, M_cr: float, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчет коэффициента силы лобового сопротивления при нулевом угле атаки

        Ввод:   M: float - число Маха
                M_cr: float - угол атаки, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности крыла, К
        Вывод:  c_xa0: float - коэффициент силы лобового сопротивления при нулевом угле атаки
        '''

        # Коэффициент профильного сопротивления крыла
        c_xa_pr = self.c_xa_pr(M, H, xx_t, T_s)

        # Коэффициент волнового сопротивления крыла
        c_xa_w = self.c_xa_w(M, M_cr)        

        # Коэффициент донного сопротивления крыла
        c_xa_dn = self.profile.c_xa_dn(M)

        # Коэффициент силы лобового сопротивления крыла при нулевом угле атаки
        c_xa_0 = c_xa_pr + c_xa_w + c_xa_dn

        # Результат
        return c_xa_0

    @checkSavedValue
    def c_xai(self, M: float, alpha: float) -> float:
        '''
        Расчет коэффициента индуктивного сопротивления

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
        Вывод:  c_xa_i: float - коэффициент индуктивного сопротивления
        '''
        # Коэффициент нормальной силы крыла
        c_y = self.c_y(M, alpha)
        
        # Вызываем библиотечную функцию для определения коэффициента пропорциональности подсасывающей силы
        cc_F = AeroBDSM.get_CC_F_IsP(M, self.lambd, self.chi_0).Value

        # Вызываем библиотечную функцию для определения коэффициента реализации подсасывающей силы
        Sigma_CF = AeroBDSM.get_Sigma_CF(M, self.chi_0, abs(alpha)).Value

        # Коэффициент подсасывающей силы
        c_F = self.profile.rr_0 * Sigma_CF * cc_F * c_y ** 2

        # Коэффициент индуктивного сопротивления крыла
        c_xa_i = c_y * sin(alpha) - c_F * cos(alpha)
    
        # Результат ,в интерференции надо будет учесть ещё с_у индуцированный на фюзеляже и направленный по альфа, а не альфа_эфф (с.247)?
        return c_xa_i

    

    @checkSavedValue
    def c_xa(self, M: float, alpha: float, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчет коэффициента силы лобового сопротивления

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности крыла, К
        Вывод:  c_xa: float - коэффициент силы лобового сопротивления
        '''

        # Критическое число Маха при данном угле атаки
        M_cr = self.M_cr(M, alpha)

        # Коэффициент силы лобового сопротивления при нулевом угле атаки
        c_xa0 = self.c_xa0(M, M_cr, H, xx_t, T_s)

        # Коэффициент индуктивного сопротивления
        c_xai = self.c_xai(M, alpha)

        # Коэффициент силы лобового сопротивления крыла
        c_xa = c_xa0 + c_xai

        # Результат
        return c_xa

    @checkSavedValue
    def c_x(self, M: float, alpha: float, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчет коэффициента продольной силы 

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности крыла, К
        Вывод:  c_x: float - коэффициент продольной силы
        '''
        
        # Коэффициент нормальной силы
        c_y = self.c_y(M, alpha)

        # Коэффициент силы лобового сопротивления
        c_xa = self.c_xa(M, alpha, H, xx_t, T_s)

        # Коэффициент продольной силы крыла
        c_x = (c_xa - c_y * sin(alpha)) / cos(alpha)

        # Результат
        return c_x

    @checkSavedValue
    def c_ya(self, M: float, alpha: float, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчет коэффициента подъемной силы

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности крыла, К
        Вывод:  c_ya: float - коэффициент подъемной силы
        '''

        # Коэффициент нормальной силы
        c_y = self.c_y(M, alpha)

        # Коэффициент силы лобового сопротивления крыла
        c_xa = self.c_xa(M, alpha, H, xx_t, T_s)

        # Коэффициент подъёмной силы крыла        
        c_ya = (c_y - c_xa * sin(alpha)) / cos(alpha)

        # Результат
        return c_ya

    @checkSavedValue
    def x_F_alpha(self, M: float) -> float:
        '''
        Расчет координаты фокуса по углу атаки

        Ввод:   M: float - число Маха
        Вывод:  x_F_alpha: float - координата фокуса, отсчитываемая от носка бортовой хорды, м
        '''
        
        # Вызываем библиотечную функцию для определения относительной координаты фокуса, отсчитанной от начала САХ и выраженной в долях САХ
        xx_F_alpha = AeroBDSM.get_Coordinate_xxF_IsP(M, self.lambd, self.chi_05, self.zeta).Value
        
        # Координата фокуса
        x_F_alpha = self.x_A + self.b_A * xx_F_alpha

        # Результат
        return x_F_alpha

    @checkSavedValue
    def x_d(self, M: float, alpha: float) -> float:
        '''
        Расчет продольной координаты центра давления

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад                
        Вывод:  x_d: float - продольная координата центра давления изолированного крыла, отсчитываемая от носка бортовой хорды, м
        '''
        
        # Производная коэффициента нормальной силы крыла по углу атаки
        c_y_alpha = self.c_y_alpha(M)

        # Коэффициент нормальной силы крыла
        c_y = self.c_y(M, alpha)

        # Вызываем библиотечную функцию для определения коэффициента, характеризующего нелинейность коэффициента нормальной силы крыла
        A = AeroBDSM.get_A_IsP(M, self.zeta, c_y_alpha).Value

        # Координата фокуса крыла
        x_F_alpha = self.x_F_alpha(M)        
        
        if c_y == 0:
            #При нулевой подъёмной силе центр давления отсутствует, условно принимаем что центр давления совпадает с фокусом
            return x_F_alpha        
        else:
            # Предполагая, что линейная по углу атаки составляющая нормальной силы приложена в фокусе,
            # а нелинейная - в центре тяжести площади крыла в плане, рассчитываем центр давления
            # суммарной силы таким образом, чтобы создаваемый ею момент был равен сумме моментов от двух составляющих      
            x_d = (self.c_y_alpha(M) * sin(alpha) * cos(alpha) * x_F_alpha + 
                   A * sin(alpha) ** 2 * sign(alpha) * self.x_cS) / c_y

        # Результат
        return x_d

    @checkSavedValue
    def z_dc(self, M: float, alpha: float) -> float:
        '''
        Расчет поперечной координаты центра давления консоли

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад       
        Вывод:  z_dc: float - поперечная координата центра давления консоли (отсчитываемая от бортовой хорды), м
        '''
        
        # Производная коэффициента нормальной силы крыла по углу атаки
        c_y_alpha = self.c_y_alpha(M)

        # Коэффициент нормальной силы крыла
        c_y = self.c_y(M, alpha)

        # Вызываем библиотечную функцию для определения коэффициента, характеризующего нелинейность коэффициента нормальной силы крыла
        A = AeroBDSM.get_A_IsP(M, self.zeta, c_y_alpha).Value

        # Координата фокуса крыла
        # Вызываем библиотечную функцию для определения относительной поперечная координаты центра давления консоли
        zz_F_alpha = AeroBDSM.get_Coordinate_zz_d(M, self.lambd, self.chi_05, self.zeta).Value

        # Поперечная координата центра давления консоли
        z_F_alpha = self.l / 2 * zz_F_alpha
        
        if c_y == 0:
            #При нулевой подъёмной силе центр давления отсутствует, условно принимаем что центр давления совпадает с фокусом
            return z_F_alpha        
        else:
            # Предполагая, что линейная по углу атаки составляющая нормальной силы приложена в фокусе,
            # а нелинейная - в центре тяжести площади крыла в плане, рассчитываем центр давления
            # суммарной силы таким образом, чтобы создаваемый ею момент был равен сумме моментов от двух составляющих      
            z_d = (self.c_y_alpha(M) * sin(alpha) * cos(alpha) * z_F_alpha + 
                   A * sin(alpha) ** 2 * sign(alpha) * self.z_cS) / c_y

        # Результат
        return z_d

    @checkSavedValue
    def m_z_alpha(self, M: float, xx_0: float) -> float:
        '''
        Расчет производной коэффициента продольного момента по углу атаки

        Ввод:   M: float - число Маха
                xx_0: float - относительная координата точки, относительно которой определяется момент (в долях САХ от носка САХ) 
        Вывод:  m_z_alpha: float - производная коэффициента продольного момента по углу атаки, 1/рад
                
        '''

        # Производная коэффициента нормальной силы
        c_y_alpha = self.c_y_alpha(M)

        # Координата фокуса
        x_F_alpha = self.x_F_alpha(M)

        # Координата точки, относительно которой определяется момент
        x_0 = self.x_A + self.b_A * xx_0

        # Производная коэффициента продольного момента по углу атаки
        m_z_alpha = c_y_alpha * (x_0 - x_F_alpha) / self.b_A

        # Результат
        return m_z_alpha

    @checkSavedValue
    def m_z_omega_z(self, M: float, xx_0: float) -> float:
        '''
        Расчет коэффициента продольного демпфирующего момента

        Ввод:   M: float - число Маха
                xx_0: float - относительная координата центра вращения в долях САХ (от носка САХ) 
        Вывод:  m_z_omega_z: float - коэффициент продольного демпфирующего момента, с/рад
        '''

        # Производная коэффициента нормальной силы по углу атаки
        c_y_alpha = self.c_y_alpha(M)

        # Дозвуковое обтекание крыла [И. В. Остославский - "Аэродинамика самолета" (стр. 319)]
        if M < 1:
            
            # Относительная координата
            xx_1 = (self.eta + 2) * (self.eta - 1) / (12 * self.eta * (self.eta + 1))

            # Относительная величина САХ крыла
            bb_A = 2 / 3 * (self.eta ** 2 + self.eta + 1) / (self.eta * (self.eta + 1))

            # Функция А продольного демпфирующего момента крыла
            A = (xx_1 + xx_0 * bb_A) * (xx_1 + xx_0 * bb_A - (3 * self.eta + 1) / (4 * self.eta)) + (2 * self.eta + 1) / (16 * self.eta)
            
            # Функция B продольного демпфирующего момента крыла
            B = (self.eta - 1) / (self.eta + 1) * ((7 * self.eta ** 2 + self.eta - 2) / (144 * self.eta ** 2) - (xx_1 + xx_0 * bb_A) / 6)

            # Функция C продольного демпфирующего момента крыла
            C = ((self.eta + 2) / (12 * self.eta)) ** 2 - (self.eta + 2) / (24 * self.eta) * bb_A + bb_A ** 2 / 12

            # Функция D продольного демпфирующего момента крыла
            D = pi / 8 * (self.eta ** 2 + self.eta + 1) / (3 * self.eta ** 2)

            # Коэффициент продольного демпфирующего момента крыла
            m_z_omega_z = (-1) * c_y_alpha * cos(self.chi_05) * (A + B * self.lambd * tan(self.chi_05) + C * self.lambd ** 2 * tan(self.chi_05) ** 2) - D

        # Сверхзвуковое обтекание крыла [А. А. Лебедев и Л.С. Чернобровкин - "Динамика полета" (стр. 275)]
        else:
            # Функция B_1 продольного демпфирующего момента крыла
            B_1 = AeroBDSM.get_Bx_demph_IsP(M, self.lambd, self.chi_05).Value

            # Функция отношения вращательной производной к производной коэффициента нормальной силы крыла
            m_z_omega_z_c_y_alpha = AeroBDSM.get_mm_z_demph_isP(M, self.lambd, self.chi_05, self.zeta).Value

            # Отношение вращательной производной к производной коэффициента нормальной силы крыла
            mm_z_omega_z = m_z_omega_z_c_y_alpha - B_1 * (1 / 2 - xx_0) - (1 / 2 - xx_0) ** 2

            # Коэффициент продольного демпфирующего момента крыла
            m_z_omega_z = mm_z_omega_z * c_y_alpha

        # Результат
        return m_z_omega_z

    @checkSavedValue
    def m_z(self, M: float, alpha: float, xx_0: float, omega_z: float = 0, H: float = 0) -> float:
        '''
        Расчет коэффициента продольного момента

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
                xx_0: float - относительная координата точки, относительно которой определяется момент (в долях САХ от носка САХ) 
                omega_z: float - угловая скорость вращения крыла вокруг оси Оz, рад/с
                H: float - высота полета, м
        Вывод:  m_z: float - коэффициент продольного момента
        '''
        
        # Координата центра давления
        x_d = self.x_d(M, alpha)

        # Координата точки, относительно которой определяется момент
        x_0 = self.x_A + self.b_A * xx_0

        # Коэффициент продольного демпфирующего момента крыла
        m_z_omega_z = self.m_z_omega_z(M, xx_0)

        # Безразмерная угловая скорость
        omega_omega_z = omega_z * self.b_A / Mach_to_v(M, H)

        # Коэффициент продольного момента крыла
        m_z = self.c_y(M, alpha) * (x_0 - x_d) / self.b_A + m_z_omega_z * omega_omega_z

        # Результат
        return m_z
    
    def geometry(self) -> Dict:
        '''
        Вывод геометрических параметров изолированного крыла

        Ввод:   ...
        Вывод:  plane_type: str - тип крыла
                b_1: float - концевая хорда крыла, м
                b_A: float - САХ (средняя аэродинамическая хорда) крыла, м
                b_b: float - бортовая хорда крыла, м
                chi_0: float - угол стреловидности по передней кромке крыла, рад
                chi_05: float - угол стреловидности по линии середин хорд крыла, рад
                chi_1: float - угол стреловидности по задней кромке крыла, рад
                chi_c: float - угол стреловидности по линии максимальных толщин крыла, рад
                eta: float - сужение крыла
                l: float - размах крыла, м
                lambd: float - относительное удлинение крыла
                S: float - площадь крыла, м^2
                x_A: float - координата начала САХ (средней аэродинамической хорды) крыла от носка бортовой хорды, м
                x_cm: float - координата центра масс крыла (от носка бортовой хорды), м
                z_A: float - расстояние между САХ (средней аэродинамической хордой) и бортовой хордой крыла, м
                zeta: float - обратное сужение крыла
        '''

        # Результат
        result = {
            'plane_type': 'Неповоротное крыло',
            'b_1': self.b_1,
            'b_A': self.b_A,
            'b_b': self.b_b,
            'chi_0': degrees(self.chi_0),
            'chi_05': degrees(self.chi_05),
            'chi_1': degrees(self.chi_1),
            'chi_c': degrees(self.chi_c),
            'eta': self.eta,
            'l': self.l,
            'lambd': self.lambd,
            'S': self.S,
            'x_A': self.x_A,            
            'z_A': self.z_A,
            'zeta': self.zeta
            }

        # Результат
        return result
    
    @checkSavedValue
    def X(self, M: float, alpha: float, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчет продольной силы

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_st: float - средняя температура поверхности крыла, К
        Вывод:  X: float - сила лобового сопротивления, Н
        '''

        # Коэффициент продольной силы
        c_x = self.c_x(M, alpha, H, xx_t, T_s)

        # Продольная сила
        X = c_x * self.S * q(M, H)

        # Результат
        return X
    
    @checkSavedValue
    def Y(self, M: float, alpha: float, H: float = 0) -> float:
        '''
        Расчет нормальной силы

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
                H: float - высота полета, м
        Вывод:  Y: float - нормальная сила, Н
        '''

        # Коэффициент нормальной силы крыла
        c_y = self.c_y(M, alpha)

        # Нормальная сила крыла
        Y = c_y * self.S * q(M, H)

        # Результат
        return Y
    
    @checkSavedValue
    def X_a(self, M: float, alpha: float, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчет силы лобового сопротивления

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности крыла, К
        Вывод:  X_a: float - продольная сила изолированного крыла, Н
        '''

        # Коэффициент силы лобового сопротивления
        c_xa = self.c_xa(M, alpha, H, xx_t, T_s)

        # Сила лобового сопротивления
        X_a = c_xa * self.S * q(M, H)

        # Результат
        return X_a
    
    @checkSavedValue
    def Y_a(self, M: float, alpha: float, H: float = 0, xx_t: float = None, T_s: float = None) -> float:
        '''
        Расчет подъемной силы

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
                H: float - высота полета, м
                xx_t: float - относительная координата перехода пограничного слоя из ламинарного в турбулентный в долях рассматриваемой хорды
                T_s: float - средняя температура поверхности крыла, К
        Вывод:  Y_a: float - подъемная сила, Н 
        '''

        # Коэффициент подъемной силы крыла
        c_ya = self.c_ya(M, alpha, H, xx_t, T_s)

        # Подъемная сила крыла
        Y_a = c_ya * self.S * q(M, H)

        # Результат
        return Y_a    

    @checkSavedValue
    def M_z(self, M: float, alpha: float, xx_0: float, omega_z: float = 0, H: float = 0) -> float:
        '''
        Расчет продольного момента

        Ввод:   M: float - число Маха
                alpha: float - угол атаки, рад
                xx_0: float - относительная координата точки, относительно которой определяется момент (в долях САХ от носка САХ) 
                omega_z: float - угловая скорость вращения, рад/с
                H: float - высота полета, м
        Вывод:  M_z: float - продольный момент, Н*м
        '''

        # Коэффициент продольного момента
        m_z = self.m_z(M, alpha, xx_0, omega_z, H)

        # Продольный момент
        M_z = m_z * self.S * self.b_A * q(M, H)

        # Результат
        return M_z
    

    

    
